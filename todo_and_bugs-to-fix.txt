
** BUGS TO FIX:

[ ] Bootstrap output:
	X0,Y0 values are *not* corrected to full-image coordinates if input image used
	image subsections (e.g., for "imfit data.fits[200:400,100:300] ...", the saved
	X0,Y0 values in the bootstrap output file will be subsection-relative, although
	the "best-fit" values in the header will be correctly full-image relative.




** NEAR-TERM FUTURE TODO:

[..] Oversampling of multiple sub-regions (possibly with their own oversampled PSFs)
	-- multiple sub-regions, all with same PSF
	-- multiple sub-regions, each with its own PSF
	-- probably simpler to require that each sub-region have its own PSF; user must
	repeatedly specify the same PSF file if they want all sub-regions to share a PSF
	
	[x] Code up makeimage user interface (vector of sub-region and PSF specifications in main)
	
	[x] PsfOversamplingInfo class
		[x] Write code for class
		[x] Rewrite code to make it one instance per oversampled region
		[x] Write unit tests for class
			[x] Create unit test file and run_unittest_xxx script
			[x] Write some unit tests
			[x] Rewrite tests for updated version
			[x] Get unit tests to pass
			[x] Add unit test to run_unit_tests.sh
		[x] Add files to repo [class files, unit tests and script]
		[x] New functions: Add/GetImageOffset, GetCorrectedRegionCoords
			[x] Add unit test for AddImageOffset
			[x] Write code to pass tests
		
		LATER:
		[ ] Experiment with converting pointers used for oversampled PSFs to
		C++-11 shared_ptr. A given PSF vector is then shared among:
			* shared_ptr in PsfOversamplingInfo instance (shared_ptrs in
			multiple PsfOversamplingInfo instances could all point to a
			single pixel array)
			* shared_ptr in ModelObject::AddOversampledPsfInfo (psfPixels_osamp)
			* shared_ptr in OversampledRegion::AddPSFVector ?
			* shared_ptr in Convolver instance (psfPixels)
		TRICKY POINT: shared_ptrs by default call "delete" to de-allocate the
		memory. Memory that's been allocated via malloc/calloc instead of via "new"
		should have a "custom deleter" that calls "free"; this can be set up
		via
			std::shared_ptr<T> ptr(static_cast<T*>(malloc(sizeof(T))), free);
		See, e.g., https://stackoverflow.com/questions/12264701/shared-ptr-with-malloc-and-free			
	
	[x] Modify SetupModelObject to check for and handle multiple oversampling regions
		[x] Basic check using 2 regions w/ 1 PSF and scale

	[ ] Update SetupModelObject unit tests to account for altered interface
		[x] Update tests to handle simple case of 1 oversampled region
		[ ] Update tests to include multiple oversampled regions
	
	[x] Add use of PsfOversamplingInfo to makeimage_main.cpp
		[x] Add initial use
		[x] Modify to agree with updated version (post-integration into SetupModelObject)
	
	[x] Add regression test to do_makeimage_tests.sh to do simple test of multiple regions
		[see planning_for_mult-oversampling_tests.txt for possible starting points]
	
	[..] Modify ProcessInput in makeimage to handle multiple --overpsf* instances
		-- currently, when we specify multiple instances of e.g. --overpsf_region, only
		the last one gets recorded in the OptionParser object
		[ ] Modify commandline_parser to handle multi-instance options
			[x] Plan out possible interface
			[ ] Add unit tests to unittest_commandline_parser.t.h
			[ ] Write code to make tests pass
			?[ ] Consider rewriting commandline_parser to make all OptionParser objects
			the same (with internal vector), with behavior (singleton or vector)
			depending on how constructor is called
		
		[x] Update ProcessInput in makeimage to use multi-instance options
		[x] Update ProcessInput in imfit to use multi-instance options
		
	[x] Code up array of sub-region convolutions in ModelObject
		[x] New data members: nSubregions
		[x] Start with 1-element array (i.e., have all the looping, etc., but just one sub-region)
		[x] Add in code to set up multiple sub-regions

	[x] Modify imfit_main.cpp to handle multiple oversampling regions
		[x] Modify ProcessInput to include & handle options (as in makeimage)
		[x] Modify main() to handle multiple regions (as in makeimage)
		[x] Add code to pass in image offsets (X0_offset, Y0_offset) to psfOveramplingInfo objects
	
	[..] Modify mcmc_main.cpp to handle multiple oversampling regions
		[x] Modify ProcessInput to include & handle options (as in imfit)
		[ ] Update ProcessInput in imfit-mcmc to use multi-instance options
		[ ] Modify main() to handle multiple regions (as in imfit)
	
	[x] Check that both PSF-oversampling tests in do_imfit_tests.sh work
	
	[ ] Add regression test to do_imfit_tests.sh to do simple test of multiple regions
	
	[ ] Modify EstimateMemory (and code calling it in _main.cpp) to account for
	multiple oversampled regions
	
	[ ] LATER: Comment out or remove GetAllCoordsFromBracket2 from utilities, since we no longer
	need it?


[ ] MCMC program: "imfit-mcmc"
	
	[ ] Feedback from dream()
		[ ] Detect failed opening of output files, complain and exit
		[ ] Detect failed write to output files, complain and exit?
		[x] Return values indicating: convergence vs max-iterations
		[ ] Record and report cumulative number of likelihood evaluations
		[ ] Print (and maybe report) total number of iterations

	[ ] Possible speedup for dream(): delay writing of output until end
		of process
		-- currently, dream() writes output once per generation for each chain.
		Possibly there is some cleverness in the streams output where things are
		buffered until later, but if not, we might gain some speedup (esp. on 
		machines with traditional hard disks) if we delay writing the chains
		until the end.
		
	[ ] No-convergence-test mode
		-- flag which tells dream() to ignore results of convergence tests and just
		keep on going until p->maxEvals is reached.
		-- "--ignore-convergence" ?
		
	[x] Better headers for MCMC output
		[x] Look for code that defines bootstrap output header
		[x] Adapt code for bootstrap output header to MCMC output
		[x] Add printing of input parameter file to header

	[x] Create mcmc main.cpp as copy of imfit_main.cpp
		[x] Make copy
		[x] Change internal strings describing name
		
		[x] Remove command-line code specifying fit algorithm
		[x] Remove command-line code specifying fit parameters (e.g., tolerance)
		[x] Remove code in main() which calls fitting algorithm
		[x] Remove bootstrap-related code in main()
	
	[x] Create target in SConstruct file for mcmc program
		[x] Copy existing makeimage code
		[x] Modify code to use new program name
	
	[x] Create simple regression test for mcmc program
		[x] Identify small test image (e.g., exponential, very small image)
		[x] Do test run of MCMC code to ensure output look sensible
		[x] Set up run of MCMC code using fixed RNG seed
		[x] Set up do_mcmc_test.sh
		[x] Test run of do_mcmc_test.sh
	
	[ ] Add to regression tests for imfit-mcmc
		[x] Add some error-detecting regression tests
		
	[x] Link/copy/add cdream code
		[x] 1. create symlink to cdream code
		[x] 2. create new subdirectory holding cdream code (and add code to repo)
	
	[x] Options struct for mcmc program
		[x] Add CDREAM-related elements from profilefit_mcmc
		[x] Add command-line processing code to fill in CDREAM-related elements
	
	[x] Add cdream-related stuff to main
		[x] Add declaration and setup of dream_pars struct
		[x] Add code passing command-line options to dream_pars
		
	[x] Cleanup of main
		[x] Remove parameterInfo-related code
		
	[x] Command-line options for mcmc program
	
	[x] Locate image, model used for bootstrap demo in Erwin 2015
	/Users/erwin/Documents/Working/Papers-Finished/Paper-imfit/image_tests/sersictest_lowsn200.fits
	~/coding/imfit/imfit -c config_imfit_sersic1.dat sersictest_lowsn200.fits --mlr --bootstrap 500 --save-bootstrap bootstrap_out_lowsn200_modcash.dat
	Both files copied to ~/coding/imfit

		./imfit -c config_imfit_sersic1.dat sersictest_lowsn200.fits --mlr --bootstrap 500 --save-bootstrap bootstrap_out_lowsn200_500.dat
		t = 20.0 sec
		./imfit-mcmc -c config_imfit_sersic1.dat sersictest_lowsn200.fits --mlr -o mcmc_out_lowsn200
		t = 353 sec
		
		colnames, d_mcmc_lowsn200 = MergeChains('mcmc_out_lowsn200', last=5000)

	[x] Clean up/rationalize output chain files
		[x] "gen" is currently useless cycling of 0,...9,
	
	[ ] replace C++ streams with stdio?
		[x] replace C++ streams with stdio in dream_initialize.cpp
		[x] replace C++ streams with stdio in dream_pars.cpp
		[ ] replace C++ streams with stdio in dream.cpp
		[x] replace C++ streams with stdio in gelman_rubin.cpp
		[x] replace C++ streams with stdio in gen_CR.cpp

	[ ] Command-line option to do N rounds of image generation to estimate time/model?
		--estimate-time = flag to do time estimate (including, by default, 1 round of
			model-image-generation)
		--timing <N> = optional command specifying number of model-image-generation
			rounds to do (as in makeimage)
		
		-- Print summary of estimated run time
			minimum time = t_model * nBurnin * numChains
			maximum time = t_model * maxEvals * numChains
		Note that main loop in dream.cpp is
		for (int t = prevLines + 1; t < p->maxEvals; ++t) {
		which is guaranteed to run until
		t >= burnInStart + p->burnIn
			where burnInStart is 0 by default (and only gets reset if the algorithm
			re-enters burn-in, so we can safely assume that the *minimum*
	
	[ ] Python script to convert user-specified line in an MCMC output file to
	makeimage/imfit config file
		-- Also a version to do same with bootstrap output?
		-- Internal code to hold functions+parameters in form similar to Andres' code??
	
	[x] Modify dream.cpp: Experiment with converting every-5th-generation code in dream.cpp (roughly,
	lines 205--225) to be more like what Vrugt et al. do
		-- Vrugt et al. seem to recommend setting gamma = 1.0 every 5th generation
		-- Code in dream.cpp 
			[x] remove lines ~ 205--225 ("if (gammaGeneration++ == 5) { ... }")
			[x] modify line ~ 269 ("gamma = 2.38/sqrt(2.0*updateDim[i]*delta);") 
			to set gamma = 1.0 if t % 5 == 0
	
	[ ] Modify dream.cpp: Add beta_0 parameter from Vrugt 2016?
		-- beta_0 is an optional scaling of the normal gamma: gamma' = beta_0 * gamma
		By default, beta_0 = 1.0; Vrugt 2016 suggests beta_0 between 0.25 and 0.5 can
		be useful for complicated, multi-dimensional posteriors
			[] Add beta_0 parameter to parameter struct
			[] modify line ~ 269 ("gamma = 2.38/sqrt(2.0*updateDim[i]*delta);") 
			to be something like "gamma = beta_0 * 2.38/sqrt(2.0*updateDim[i]*delta);"
			[] Test beta_0 = 0.25 and 0.5 to see if it helps or hinders us

	[ ] Modify dream.cpp: Add proper handling of parameter bounds ??
		-- currently, dream.cpp uses parameter bound by setting likelihood = -INFINITY
		if proposal variable value is outside bounds (thus rejecting the proposal)
		-- see p.269 of Vrugt 2016 for options on handling parameter bounds
	


[..] Possible optional parameters for image functions in config file
	"params"? "settings?"
	-- ways to specify optional settings, or even input parameter files that
	function can read when first starting up
	-- optional keywords after FUNCTION but before parameters?
		e.g.
		FUNCTION blah
		OPTIONAL_PARAMS_START
		xxx
		OPTIONAL_PARAMS_END
		
		or even just
		FUNCTION blah
		xxx
		OPTIONAL_PARAMS_END
		
		The following should be acceptable (and interpreted as "no optional params supplied")
		FUNCTION blah
		OPTIONAL_PARAMS_START
		OPTIONAL_PARAMS_END

	Read and stored as something like dict of string: string pairs. If this exists
	for a given function, then it is passed to function object just after initialization
	(e.g., just after calling AddFunction)
	
	Output (e.g., best-fit parameters): do we list 
		For best-fit params, we *should* list anything that was explicitly set by
		the user
		If none of the optional params were set by the user, should we still list them?
		(Confusing if best-fit output doesn't match format of config file!)
		(Alternate view: optional params *define* the function, so they should always
		be listed...)
		
	Function object has extra method for handling input dict (defaults to a do-nothing)
		-- e.g., it knows which values to convert to ints or doubles, how to
		interpret different keywords, etc.

	    virtual int FunctionObject::SetExtraParams( map<string, string> )
	
	
  vector<map<string, string>> optionalParamsVect;
  # one map per function; most or all such maps probably will be empty
  
  for (n = 0; n < nFunctions; n++) {
    if (fblockStartFlags[n] == true) {
      // start of new function block: skip over existing x0,y0 values
      offset += 2;
    }
    functionObjects[n]->SetExtraParams(optionalParamsVect[n]);
    functionObjects[n]->Setup(params, offset, x0_all, y0_all);
    offset += paramSizes[n];
  }
  
  OR
    if (functionObjects[n]->HasExtraParams())
      functionObjects[n]->SetExtraParams(optionalParamsVect[n]);
  
  SIMPLER APPROACH:
     extra params are added to function *once*, when it is created inside
     AddFunctions (add_functions.cpp)
     	-- this way, ModelObject doesn't need to know about the extra options
     	at all! (Think of it this way: optional parameters are for specializing
     	the function *before* it is used in the model, and shouldn't ever need
     	to be adjusted during the fitting process.)
     		-- only problem: how can we record the optional-parameter values in
     		the output?
     		-- New method for FunctionObject which prints out extra params
     		E.g., in ModelObject::PrintModelParams and ModelObject::PrintModelParamsToStrings, 
     		just after printing the function name, we check to see if it has optional 
     		parameters, and if so, we ask the FunctionObject to print their names & values

		Uses:
			1. ReadConfigFile retrieves optional params in optional-params-vector
				*_main.cpp; config_file_parser.cpp
			2. AddFunctions takes optional-params-vector, uses it to modify FunctionObjects
			via their SetExtraParams methods
				add_functions.cpp; FunctionObjects
			3. ModelObject gets parameter names and value from FunctionObjects as
			part of ModelObject::PrintModelParams and ModelObject::PrintModelParamsToStrings
				model_object.cpp; FunctionObjects
			
		[x] Add input method to FunctionObject
			[x] Write unit tests to check input and processing of simple case
			[x] Write code to pass unit tests
		[x] Add input method to 2D FunctionObject subclass
			[x] Write unit tests to check input and processing of 2D FunctionObject subclass
			[x] Write code to pass unit tests
			
		[] Add processing code to config_file_parser.cpp
			-- needs to accept & return an optional-params vector< map<string,string> >
			[x] Write sample config file with optional parameters
				-- config_makeimage-optional_params*.dat
			[x] Write unit tests for VetConfigFile
			[] Write unit test for ReadConfigFile to check input and processing of 1 optional parameter
			[] Write unit test for ReadConfigFile to check input and processing of multiple optional parameters
			[] Write unit test for ReadConfigFile to check input and processing of multiple optional parameters
				for multiple functions
			[] Write code (modify ReadConfigFile) to pass unit tests
		[] Modify code in _main.cpp to set up optional-params vector for calls to
		ReadConfigFile and then pass it into call to AddFunction
			[] makeimage_main.cpp
				[x] add code
				[] add regression test to see that we correctly use GaussianExtraParams
					-- i.e., config file w/ and w/o extra-parameter specification
					-- compare output images against reference images
					-- Problem: this only works if we compile makeimage with GaussianExtraParams,
					but that is currently only included if we use -DUSE_TEST_FUNCS
			[x] imfit_main.cpp
			[x] mcmc_main.cpp

		[] Add printout code to FunctionObject
			-- to be used in e.g. ModelObject::PrintModelParams and also in
			ListFunctionParameters in add_functions.cpp [might be confusing, though,
			since these are *optional* parameters
				==> new command-line option "--list-parameters-with-options" ?]
		[] Modify ModelObject::PrintModelParams and ModelObject::PrintModelParamsToStrings
		to check for and get optional-params from FunctionObjects
			[] Add unit test (to unittest_model_object) to check PrintModelParamsToStrings
			[] Write code to pass unit test
			[] Modify PrintModelParams
		[] Add input method to ModelObject
			[] Write unit test to check input and processing of 1 or more input dicts
			[] Write code to pass unit tests

		
		[] Add optional-parameter processing code to func1d_spline.cpp
			-- additive constant
			[] Write unit test to check input and processing
			[] Write code to pass test
			[] Generate and check output
				[] config file without optional parameter
				[] config file with optional parameter
				[] config file with optional parameter (different value)



[ ] Separate the code which does doing model-image-generation timing into separate file
	(so it can be used by both makeimage and imfit-mcmc)
	
[-] Implement Kahan summation in ModelObject::FindTotalFluxes
	-- http://stackoverflow.com/questions/18013345/openmp-parallel-for-reduction-delivers-wrong-results
	[x] Compute some current flux outputs (e.g., including correct total flux for Exponential)
	[x] Implement Kahan summation
	[x] Compare results with/without Kahan summation
	
	RESULT: for case of simple Gaussian model, Kahan summation took 2--3 times as long
	and produced *no* difference in calculated flux (at 10^-5 level), even for a
	very extended Gaussian.


[] Convert total-pixel-number integer variables to long
	[X]model_object.h: nModelVals, nDataVals, nValidDataVals, nOversampledModelVals
	[X]model_object.cpp: 
		ModelObject::AddErrorVector( int nDataValues
		ModelObject::AddMaskVector( int nDataValues
		ModelObject::AddPSFVector( int nPixels_psf
		ModelObject::AddOversampledPSFVector( int nPixels
		theModel->GetNValidPixels() -- should return long
		int ModelObject::FinalSetupForFitting( ) -- nNonFinitePixels, nNonFiniteErrorPixels
		Assorted for-loop index variables when looping over pixels
		bootstrap indices
			-- also make sure RNG can return long values

	[X]convolver.h: nPixels_image, nPixels_psf, nPixels_padded; nPixels_padded_complex
	[X]convolver.cpp: Convolver::ShiftAndWrapPSF( ) -- pos_in_psf, pos_in_dest;
	oversampled_region.h: nModelVals
	oversampled_region.cpp: ---
	[X]image_io.cpp: 
		ReadImageAsVector -- nPixelsTot
	[X]makeimage_main.cpp: 
	[X]imfit_main.cpp: 
	[X]print_results.cpp
	[X]statistics.cpp -- aic, bic [nValidPixels]


[..] Add "const" specifiers to input parameters of functions, as appropriate
	Done through: convolver


[] Possible improved error reporting
	[] When negative pixel values are encountered during vetting of input data image,
	mention possibility of missing sky parameter


[..] Spline-interpolation image function
	-- radial SB profile (usually exponential, Sersic, etc.) is spline interpolation
	using a small set of r, I values. The I values are free parameters of the fit;
	possibly the r values could be also.
	-- function has the usual PA, ellipticity parameters to define r_scaled;
	optionally c_0 as well for boxy/disky isophotes
	-- possible way to handle changing radii for interpolation points:
	when parameter vector is passed to image function in Setup(),
	*sort* the parameters by radius, then do interpolation with the sorted
	vector of r,I


[] Modify handling of oversampled PSF to catch case where user wants entire
image oversampled
	-- e.g., if total number of pixels in main + oversampled region (model images,
	including edge-padding for PSF) > number of pixels in hypothetical oversampling
	of entire image ==> switch to oversampling of entire image

	-- need to test this to make sure time spent isn't wrongly estimated (e.g.,
	actual time with oversampling includes FFT + downsampling)
	
	-- add option for user to specify this directly?
	e.g. "--overpsf_region all"


[] Combine code for generating output header 
	Currently: lines 329--335 and also 369--375 of print_results.cpp
	-- generate in main() as list of strings?
	-- would allow us to remove "string& programName, int argc, char *argv[]" from
	interface of SaveParams() and SaveParams2()


[..] Reorganize directory structure:
	[x]src/core
	[x]src/solvers
	[x]src/function_objects
	src/function_objects_extra -- for specialized, non-public stuff (n4762 funcs, experimental stuff, etc.)
	[x]src/function_objects_1d
	[x]src/profilefit -- for all the 1D stuff (except func1d_*)
	src/utilities ?
	src/extra ? -- for timing_main.cpp
	src/model_object ? -- for model_object convolver oversampled_region downsample
		[but note that Convolver is used by psfconvolve_main.cpp
	[x]tests/ -- regression tests, etc.
	[x]unit_tests/
	[x]docs/ -- where Doxygen input files go
		html -- created by Doxygen
		latex -- created by Doxygen
	
	[] Possibly create SConstript files for subdirectories -- see 
	http://stackoverflow.com/questions/8810418/scons-setup-for-hierarchical-source-but-single-target
	[or maybe not, since that's getting into "recursive Makefile considered harmful"
	territory, even if SCons isn't necessarily afflicted with the same problems]


[] Refactor print_results.cpp to be simpler and less mangled-from-mpfit


[] Look into possible use of FFTW++ library for convolution
	-- C++ wrapper around FFTW, with added optimization for "implicit zero-padding"
	of convolutions

[] Optional convolution with charge-diffusion kernel?


[] Annotations to describe function parameters
	-- optional text strings in a FunctionObject class which provide a short, one-line
	description/reminder of what the parameter is (and maybe its units?)
	-- printed on same line as parameter name, with "#" in between
	-- possibly alternate command-line flag to specify this instead of the
	current, "bare-bones" version


[] User annotations for functions in config file
	-- i.e., allow user to add names to individual functions, e.g.
	FUNCTION Sersic   # NGC 100: bulge
	or:
	FUNCTION Sersic   LABEL = NGC 100: bulge
	-- these would be stored and written to output files


[] Compiling parts of program(s) into a library, which is then linked when
compiling imfit and makeimage (and other things, like timing). Idea is to set
things up so it's easier for other people to use "libimfit" without the
specific input/output functionality/limitations of imfit/makeimage.



** MINOR BUGS TO FIX/IMPROVEMENTS TO MAKE:

[ ] When imfit saves bootstrap output, X0,Y0 values are *not* corrected for
cfitsio offset values
	E.g., for X0,Y0 = 125,604 in image.fits[100:300,500:800], the saved
	X0,Y0 vaalues are 25,104


[ ] In imfit and imfit-mcmc, oversampled-convolution regions are referenced by
a string: options.psfOversampleRegion

	The x1,x2,y1,y2 boundaries of the oversampled region are extracted from this string:
    if (! options.oversampleRegionSet) {
		GetAllCoordsFromBracket(options.psfOversampleRegion, &x1_oversample, ...)
		
	In makeimage, oversampled-convolution regions are referenced by a *vector*
of string: options.psfOversampleRegions
	the x1,x2,y1,y2 boundaries are extracted from the vector; effectively, only the
	*last* string in the vector is actually used (since we loop over the vector, but
	keep assigning the output to the same int variables):
	
    if (! options.oversampleRegionSet) {
    ...
    for (int ii = 0; ii < options->nOversampleRegions; ii++)
      GetAllCoordsFromBracket2(options->psfOversampleRegions[ii], x1_oversample, x2_oversample, 
    						y1_oversample, y2_oversample);

	SO:
		imfit,imfit-mcmc assume a single oversampled region, stored in options.psfOversampleRegion
		makeimage assumes *multiple* oversampled regions, stored in options.psfOversampleRegions
		BUT: the rest of makeimage assumes there's only one oversampled region (and only
		one oversampled PSF).




* BUGS FIXED

[X] PSF oversampling:
	Small deviations in output image were present when generated using current working
	version of makeimage (pre-1.5) with internal OversampledRegion vector vs when generated with
	v1.4 of makeimage. (Also present when generated using makemultimages.)
	
	FIXED: Problem was that oversampling was *not being done*, because the ModelObject
	instance wasn't getting told in SetupModelObject() about the oversamplng, because we 
	weren't setting the correct variables in the MakeimageOptions object in main 
	(i.e., psfOversamplingScale and oversampleRegionSet [which are in base class] --
	note that the former is distinct from the vector version psfOversamplingScales).
	Fixed by explicitly setting options->oversampleRegionSet and
	options->psfOversamplingScale before calling SetupModelObject().
	
	

[X] Convolution of an image with substantial region of negative pixels produces
weird ringing and positive pixels in negative region.
	Reported by Semyeong Oh
	-- tests using astropy.convolution.convolve() and astropy.convolution.convolve_fft()
	show apparently correct results
	-- see if this also happens with 1-D convolution?
	?? Is output the absolute value of what it should be?
		-- compare with astropy.convolution output
			[]1. Compare astropy.convolution output on all-positive image (how much
			does our convolution differ from theirs?)
			[]2. Compare astropy.convolution output on partially-negative image
	-- This turns out to have been a longstanding bug due to the fact that I ahd
	(for some mysterious reason) taken the absolute value of the inverse transform
	at the end of the convolution. This had no effect when all pixels were >= 0,
	but was wrong for negative pixels... Accidentally fixed in version 1.3 when
	I changed how the transform was computed.


[X] --quiet option with Nelder-Mead simplex (--nm) is not truly quiet (some of N-M
simplex output is suppressed, but "iteration XXX" is still printed)
	-- OK, this is a difference between the current version of NLopt library ints
	dynamic form (what we normally use) and the static-linking one

[X] Compiling with our SCons option --no-nlopt fails to catch references to NLopt
function NMSimplexFit in bootstrap_errors.cpp
	Reported by Guillermo Barro
	-- FIX: add preprocessor directives to comment out all references to NLopt stuff

[X] Doing bootstrap resampling when the input config file contains the best-fitting
solution for the model + image results in mysteriously non-existent boostrap
error estimates:
E.g., [with version 1.3b; seen by Semyeong Oh in an earlier version]
$ ./imfit tests/ic3478rss_64x64.fits --config tests/imfit_config_ic3478_64x64.dat --gain=4.725 --readnoise=4.3 --sky=130.1 --bootstrap 100
	==> OK output
$ ./imfit tests/ic3478rss_64x64.fits --config bestfit_parameters_imfit.dat --gain=4.725 --readnoise=4.3 --sky=130.1 --bootstrap 100
	==> yieds:
Best-fit		 Bootstrap      [68% conf.int., half-width]; (mean +/- standard deviation)
X0 = 32.9439     [fixed parameter]
Y0 = 34.0933     [fixed parameter]
PA = 18.2613     [fixed parameter]
ell = 0.235989     [fixed parameter]
n = 2.40028     [fixed parameter]
I_e = 20.0094     [fixed parameter]
r_e = 60.7611     [fixed parameter]

f1 = '/Users/erwin/coding/imfit/bstest1.dat'
df1 = du.ReadCompositeTableFromText(open(f1).readlines(),dataFrame=True, columnRow=14)
f2 = '/Users/erwin/coding/imfit/bstest2.dat'
df2 = du.ReadCompositeTableFromText(open(f2).readlines(),dataFrame=True, columnRow=14)

astrostat.genstats(df1.X0_1)
astrostat.genstats(df2.X0_1)
astrostat.genstats(df1.Y0_1)
astrostat.genstats(df2.Y0_1)
astrostat.genstats(df1.n_1)
astrostat.genstats(df2.n_1)

OK, bootstrap output from 2nd case (starting with best-fit values) seems similar to
first case (starting from original guesses), so *that* part works...

OK, here is the problem:
	1. In BootstrapErrors(), we check for *fixed* parameters with this:
    if ((paramLimitsExist) && (parameterLimits[i].fixed == 0)) {
	BUT: if the config file had no limits at all (as is always true for an output
	best-fit parameters file), then paramLimitsExist = false
	
	Confirmed by removing all the limits from the regular param file
		==> produces the same "[fixed parameter]" output...
	
	[X] SOLUTION: Remove parameterLimitsExist test when determining whether to
	print conf. intervals



* IMPROVEMENTS APPLIED

[x] New function(s) to assign image data, etc. to ModelObject instance
	SetupModelObject
	-- i.e., something to collect all the "assign data, assign PSF, assign
	mask, assign image-params" stuff which could be called from imfit_main.cpp
	and also from mcmc_main.cpp [and maybe from multimfit, too]
	-- could be called repeatedly to generate multiple ModelObject instances for
	multimfit?
	
	[X] Collect program options into new classes
		[x] base options class
		[x] options class for makeimage
		[x] options class for imfit
		[x] options class for imfit-mcmc
		
	[x] Draft SetupModelObject
		[x] Simple unit tests for SetupModelObject
		[x] Unit tests for makeimage-mode; change makeimage_main.cpp
		[x] Unit tests for imfit-mode; change imfit_main.cpp
		[x] Unit tests for mcmc-mode; change mcmc_main.cpp
	
	

[X] Check for NaN values in PSF (and oversampled-PSF) images; complain and quit if found

[X] Test for possible memory-allocation failures
	[x] Reading in large images -- effectively already caught by cfitsio
	[x] Allocating memory for model images
	[x] Allocating memory for internally-generated error image
	[x] Allocating memory for weight image
	[x] Allocating FFTW arrays in Convolver
	[x] Test using makeimage and very large --nrows,--ncols ?

[X] Implement Kahan summation in PSF normalization
	Convolver::DoFullSetup

[X] New class encapsulating return metadata from minimizers (like mp_results, but
for all minimizers)

[X] Update memory estimation to account for smaller FFT-related arrays

[x] Update memory estimation to account for possible oversampled PSF use

[X] Add one or two oversampled-PSF tests to do_imfit_tests (and do_makeimage_tests)
	do_makeimage_tests -- ensure that we recreate reference image

[X] Option to output default/simple configuration file (and then quite)
	-- for imfit, this could include e.g. GAIN = 1 as well as single function
	-- for makeimage, this could include NROWS and NCOLS as well as single function

[X] FOR V1.3: Tweak output of best-fit parameters for mult-function-block case
	-- currently, additional function blocks are appended directly; would be
	nicer to have a blank line before each new "X0 ..." line
	
	
[X] FOR V1.3: King model FunctionObject
	-- function_objects/func_king.h/cpp : in progress
	-- need to set up some profile-computation tests (e.g., compare 1-D slices
	through output image with 1-D profiles generated by ...?)
		[x] Write Python code to implement function; test by generating plot
		with same ranges as Fig.10 of Peng+2010 and comparing (overlay in Illustrator?)
		[x] Generate plot with all profiles
		[x] Compare plot with Fig.10 of Peng+2010 in Illustrator
	[x]-- check that we get I= 0 for r > r_t; possibly introduce shortcut in code
	to just return 0 in that case.
		[x] Generate images (with no subsampling) and compare profiles with
		output of Python code
		[x] Set up unit tests
	[x] Add variant model where concentration (r_t/r_c) is adjustable parameter
	[x] Add notes to documentation for Modified King function


[x] FOR V1.3: Convert handling of user-supplied "weight" map ("--errors-are-weights")
	so that the user can assume "weight = inverse variance" (rather than 
	"weight = inverse simga", which is how it's actually implemented at present)
		-- set up comparison tests
		-- Need to modify ModelObject::GetWeightImageVector [used in imfit_main.cpp]
		
		[x]0. Set up unit tests
		[x]1. Modify ModelObject::GetWeightImageVector to output 1/sigma^2 weights
		[x]2. Modify ModelObject::AddErrorVector to convert "weight" input properly
		[x]3. Edit imfit_howto.tex to reflect reality of weights
		[x]4. modify do_imfit_tests to incorporate weight-map checks
				[] Input maps produce approx. same fits as internally-generated maps
				[] Output weight maps are approx. correct
				[] Input an error map and output it; check


[X] Makeimage should quit when encountering unknown command-line parameter (like imift)


[X] Solver summary info in header of bestfit_parameters output should include
	subtype of chi^2 (i.e., "(data-based)", "(model-based)", "(user-supplied noise map"),
	or something like that)


[X] Handle multi-extension FITS images
	-- at least to the point of recognizing them and complaining clearly
		
	[] When reading in a FITS file (data, mask, PSF, etc.), check to see if
	it's multi-extension
		[X] Generate error if primary HDU is *not* a 2D image
	
	[] PROBLEM: how to handle user-suppled "....fits[n]" filename?
		Need to check that image *had* at least n HDUs
		Need to explicitly check whether HDU n is an image
	
	WHERE WE ARE, WHAT TO DO NEXT:
		1. ./imfit tests/test_multiextension_hdu1empty.fits --config tests/imfit_config_ic3478_64x64b.dat
		FAILS because, inside ReadImageAsVector, CheckImage returns 2 [we think] for
		valid HDU number, but ReadImageAsVector only checks to see if value is > 0,
		and then goes ahead and reads the first HDU!
			-- ReadImageAsVector needs to check 
			-- How should ReadImageAsVector and CheckImage handle user-specified
			"[n]" HDU numbers?
		2. We need to figure out how cfitsio numbers the HDUs (is the first one always
		"[1]"? what happens if user gives "[0]"			
			OK: the answer is: "The HDU may be specified either by
			absolute position number, starting with 0 for the primary
			array, or by reference to the HDU name, and optionally, the
			version number and the HDU type of the desired extension."
			
			BUT: the documentation for fits_movabs_hdu says: "The first
			routine moves to a specified absolute HDU number (starting
			with 1 for the primary array) in the FITS file,"
			
			SO: User-specified "[n]" numbering is 0-based, but internal
			numbering is 1-based!


*[X] Check input noise map (if supplied) for NaN values and add those pixels
to mask.
			1. Go through error and mask image simultaneously, ID bad error pixels
			and add to mask
			
			
	[X] Set up example noise-map image with NaN values for testing
	[X] Apply change to:
		ModelObject::FinalSetupForFitting( )
		[after "Identify currently unmasked data pixels which have non-finite values" step]
	[X] Test change

