\documentclass[10pt]{article}
\usepackage[]{mathpazo}
% FOLLOWING DOES NOT WORK [URW Garamond NOT INSTALLED?]
%\usepackage[garamond]{mathdesign}
% FOLLOWING DOES NOT WORK [SOME METRIC FILES ARE MISSING]
%\usepackage[]{mathtime}
% FOLLOWING DOES NOT WORK [EULER FONTS NOT INSTALLED?]
%\usepackage[]{mathpple}

\usepackage{natbib}
\usepackage{hyperref}
\usepackage{color}

\usepackage{listings}
\lstset{language=C}

\setlength{\oddsidemargin}{1.0cm}
\setlength{\textwidth}{13.5cm}

\newcommand{\imfit}{\texttt{imfit}}
\newcommand{\Imfit}{\texttt{Imfit}}
\newcommand{\makeimage}{\texttt{makeimage}}
\newcommand{\Makeimage}{\texttt{Makeimage}}

\newcommand{\red}{\textcolor{red}}



\begin{document}

% Definition of title page:
\title{
  Notes for Using ``Imfit''
}
\author{
  Peter Erwin\\
  MPE and USM\\
  \href{mailto:erwin@sigmaxi.net}{erwin@sigmaxi.net}
}
\date{\today}  % optional

\maketitle

\tableofcontents


\section{What Is It?}

\Imfit{} is a program for fitting astronomical images --- more
specifically, for fitting images of galaxies, though it could certainly
be used for fitting other sources. The user specifies a set of one or
more 2D functions (e.g., elliptical exponential, elliptical S\'ersic,
circular Gaussian) which will be added together in order to generate a
model image; this model image will then be matched to the input image by
adjusting the 2D function parameters via nonlinear minimization of the total
$\chi^2$.

The 2D functions can be grouped into arbitrary sets sharing a common $(x,y)$
position on the image plane; this allows galaxies with off-center components
or multiple galaxies to be fit simultaneously. Parameters for the individual
functions can be held fixed or restricted to user-specified ranges. The
model image can (optionally) be convolved with a Point Spread
Function (PSF) image to better match the input image; the PSF image can
be any square, centered image the user supplies (e.g., an analytic 2D Gaussian
or Moffat, a \textit{Hubble Space Telescope} PSF generated by the TinyTim
program \cite{krist95}\footnote{\url{http://www.stsci.edu/hst/observatory/focus/TinyTim}}, 
or an actual stellar image).

A key part of \imfit{} is a modular, object-oriented design
that allows relatively easy addition of new, user-specified 2D image
functions. This is accomplished by writing C++ code for a new
image-function class (this can be done by copying and modifying an
existing pair of \texttt{.h/.cpp} files for one of the pre-supplied
image functions), making small modifications to two additional files to include references to
the new function, and re-compiling the program. 
%Notes are [WILL BE] provided
%to guide the interested user in adding new functions; in most cases, a
%basic working knowledge of C should suffice.

An additional auxiliary program called \makeimage{}, built from the same
codebase, exists for generating artificial galaxy images (using the same
input/output parameter-file format as \imfit{}).

\Imfit{} is an open-source project; the source code is freely available
under the GNU Public License (GPL).


\bigskip

\textbf{System Requirements:} \Imfit{} has been built and tested on
Intel-based MacOS X (Snow Leopard and Lion) and Linux (Ubuntu) systems. It uses standard C++ and
should work on any Unix-style system with a modern C++ compiler and the
Standard Template Library (e.g., GCC v4 or higher\footnote{GCC v4.2 or higher is
necessary to take advantage of OpenMP-related speedups.}). It relies on two
external, open-source libraries: version 3 of the CFITSIO
library\footnote{\url{http://heasarc.nasa.gov/fitsio/}} for FITS image I/O and
version 3 of the FFTW (Fastest Fourier Transform in the West)
library\footnote{\url{http://www.fftw.org/}} for PSF convolution.

\bigskip

\Imfit{} also makes use of Craig Markwardt's \texttt{mpfit} code (an enhanced
version of the MINPACK-1 Levernberg-Marquardt least-squares fitting code) and 
the Differential Evolution fitting code of Rainer Storn and Kenneth Price
(more specifically, a C++ wrapper written by Lester E. Godwin).



\section{Getting and Installing \Imfit{}}

\subsection{Pre-Compiled Binaries}

Pre-built binaries for Intel-based MacOS X and Linux systems, along with the
source code, are available at
\url{http://www.mpe.mpg.de/~erwin/code/imfit/}. The pre-compiled binaries included
statically linked versions of the CFITSIO, FFTW, and GSL libraries, so you do
not need to have those installed.


\subsection{Building \Imfit{} from Source: Outline}

\begin{enumerate}
\item Install the CFITSIO library.

\item Install the FFTW library --- note that if you have a multi-core CPU (or
multiple CPUs sharing main memory), you should install the threaded version of
FFTW as well, since this speeds up PSF convolution.

\item (Optional) Install the GNU Scientific Library (GSL) --- this is only necessary
if you wish to use 2D image functions that rely on GSL.  Currently, the only
such function is the EdgeOnDisk (\texttt{func\_edge-on-disk.cpp}) component, which
uses a modified Bessell function. \Imfit{} can be built without this component.

\item Install SCons.

\item Build \imfit{} and \makeimage.

\item (optional) Run test scripts \texttt{do\_imfit\_tests} and \texttt{do\_makeimage\_tests}.

\end{enumerate}

\subsection{Building \Imfit{} from Source: Details}\label{sec:build}

Assuming that CFITSIO and FFTW (and optionally GSL) have already been installed
on your system, unpack the source-code tarball (imfit-x.x-source.tar.gz) in some convenient
location.

\Imfit{} uses SCons for the build process; SCons is a Python-based build system
that is somewhat easier to use and more flexible than the traditional \texttt{make}
system. SCons can be downloaded from \url{http://www.scons.org/}.

If things are simple, you should be able to build \imfit{} and the companion
program \makeimage{} with the following commands:
\begin{quote}
\texttt{\$ scons imfit} \\
\texttt{\$ scons makeimage}
\end{quote}
This will produce two binary executable files: \imfit{} and \makeimage{}. Copy
these to some convenient place on your path.

If you do not have GSL installed, you will get compilation errors; use the following
commands instead:
\begin{quote}
\texttt{\$ scons --no-gsl imfit} \\
\texttt{\$ scons --no-gsl makeimage}
\end{quote}

Various other compilation options may be useful; these are explained in the next
subsections (note that all the SCons options can be combined on the command line).

Finally, there are two shell scripts -- \texttt{do\_imfit\_tests} and \texttt{do\_makeimage\_tests} --
which can be run to do some very simple sanity checks (e.g., do the programs fit
some simple images correctly, are common config-file errors caught, etc.). They make
use of files and data in the \texttt{tests/} subdirectory. (For the full set of tests
to run, you should have Python version 2.6 or 2.7 installed, along with the
numpy\footnote{\url{http://numpy.scipy.org/}} and 
pyfits\footnote{\url{http://www.stsci.edu/institute/software_hardware/pyfits}} Python 
libraries. If these are not available, then the
parts of the tests which compare output images with reference versions will
simply be skipped.)


\subsubsection{Telling SCons Where to Find Header Files and Libraries}

By default, the SConstruct file (the equivalent of a Makefile for SCons) tells SCons
to look for header files in \texttt{/usr/local/include} and library files in
\texttt{/usr/local/lib}. If you have the FFTW, CFITSIO, and (optionally) GSL headers
and libraries installed somewhere else, you can tell SCons about this by using the
\texttt{--header-path} and \texttt{--lib-path} options:
\begin{quote}
\texttt{\$ scons --header-path=/some/path ...} \\
\texttt{\$ scons --lib-path=/some/other/path ...}
\end{quote}
(note that "\texttt{...}" is meant to stand for the rest of the compilation command,
whatever that may be).

Multiple paths can be specified if they are separated by colons, e.g.
\begin{quote}
\texttt{\$ scons --lib-path=/some/path:/some/other/path ...} \\
\end{quote}


\subsubsection{Option: Compiling with OpenMP Support}

\Imfit{} and \makeimage{} can be compiled to take advantage of OpenMP compiler support,
which speeds up image computation by splitting it up across multiple CPUs
(and multiple cores within multi-core CPUs).
Currently, the code uses OpenMP 2.5 options, which means that if you are using
the GCC compiler, you need version 4.2 or higher.

To include OpenMP support, compile using the following options:
\begin{quote}
\texttt{\$ scons --openmp imfit} \\
\texttt{\$ scons --openmp makeimage}
\end{quote}

\subsubsection{Options: Compiling without FFT Multithreading}

By default, \imfit{} and \makeimage{} are compiled to take advantage of multi-core CPUs (and other
shared-memory multiple-processor systems) when performing PSF convolutions by using the 
multithreaded version of the
FFTW library. If you do not have (or cannot build) the multithreaded FFTW library,
you can turn off multithreaded FFT computation by compiling with the following commands:
\begin{quote}
\texttt{\$ scons --no-threading imfit} \\
\texttt{\$ scons --no-threading makeimage}
\end{quote}






\section{Trying It Out}

In the \texttt{examples/} directory are some sample galaxy images, masks, PSF images, and
configuration files.

To give \imfit{} a quick spin (and check that it's working on your system), change to the
\texttt{examples/} directory and execute the following on the command line (assuming that
\imfit{} is now in your path):
\begin{quote}
\$ imfit ~ ic3478rss\_256.fits ~ \texttt{-c} ~ config\_sersic\_ic3478\_256.dat ~ \texttt{--}sky=130.14
\end{quote}

This converges to a fit in a few seconds or less (e.g., about 0.5 seconds on a 
2011 MacBook Pro with a 2.3 GHz Core i7 processor). In addition to being printed to
the screen, the final fit is saved in a file called \texttt{bestfit\_parameters\_imfit.dat}.

The preceding command told \imfit{} to fit using every pixel in the image and to estimate
the noise assuming an original (previously subtracted) sky level of 130.14, an A/D gain
of 1.0, and zero read noise (the latter two are default values). A better approach would be to include a mask (telling \imfit{}
to ignore, e.g., pixels occupied by bright stars) and to specify more accurate values
of the gain and read noise:
\begin{quote}
\$ imfit ~ ic3478rss\_256.fits ~ \texttt{-c} ~ config\_sersic\_ic3478\_256.dat ~ \texttt{--}mask ~ ic3478rss\_256\_mask.fits ~ \texttt{--}gain=4.725 \texttt{--}readnoise=4.3 ~ \texttt{--}sky=130.14
\end{quote}

If you want to see what the best-fitting model looks like, you can use the companion program \makeimage{}
on the output file:
\begin{quote}
\$ makeimage ~ bestfit\_parameters\_imfit.dat ~ \texttt{--}refimage ~ ic3478rss\_256.fits
\end{quote}
This will generate and save the model image in a file called \texttt{modelimage.fits}.

%Note that you can specify a subset of an image, thus:
%\begin{quote}
%ic3478rss\_256.fits[45:150,200:310]
%\end{quote}
%This will fit columns 45--150 and rows 200--310 of the image (column and row numbering starts
%at 1); pixel coordinates in the configuration (and output) files will refer to locations within the
%\textit{full} image.

You can also fit the image using PSF convolution, by adding the ``\texttt{--psf}'' option and a
valid FITS image for the PSF; the \texttt{examples/} directory contains a Moffat PSF image which
matches stars in the original image fairly well:
\begin{quote}
imfit ~ ic3478rss\_256.fits ~ \texttt{-c} ~ config\_sersic\_ic3478\_256.dat ~ \texttt{--}mask ~ ic3478rss\_256\_mask.fits ~ \texttt{--}gain=4.725 \texttt{--}readnoise=4.3 ~ \texttt{--}sky=130.14 ~ \texttt{--}psf ~ psf\_moffat\_51.fits
\end{quote}


The PSF image was generated using \makeimage{} and the configuration
file \\
\texttt{makeimage\_config\_moffat\_psf\_51\_for\_ic3478rss.dat}:
\begin{quote}
makeimage ~ \texttt{--}ncols=51 ~ \texttt{--}nrows=51 ~ -o ~ psf\_moffat\_51.fits ~ makeimage\_config\_moffat\_psf\_51\_for\_ic3478rss.dat  
\end{quote}




\section{Using \Imfit{}}

Basic use of \imfit{} from the command line looks like this:
\begin{quote}
  \texttt{\$ \imfit{} }  -c \textit{config-file} ~ \textit{input-image} ~ [options]
\end{quote}
where \textit{config-file} is the name of the configuration file
which describes the model (the combination of 2D functions, initial values
for parameters, and possible limits on parameter values) and \textit{input-image}
is the FITS image we want to fit with the model.

The ``options'' are a set of command-line flags and options (use ``\imfit{} \texttt{-h}''
or ``\imfit{} \texttt{--help}'' to see the complete list). Options must be followed by
an appropriate value (e.g., a filename, an integer, a floating-point number); this can
be separated from the option by a space, or they can be connected with an equals sign.
In other words, both of the following are valid:
\begin{quote}
\imfit{} ~ \texttt{--}gain 2.5 \\
\imfit{} ~ \texttt{--}gain=2.5
\end{quote}
Note that \imfit{} does not follow the full GNU standard for
command-line options and flags (as implemented by, e.g., the GNU
\texttt{getopt} library): you cannot merge multiple one-character flags
into a single item (if ``\texttt{-a}'' and ``\texttt{-b}'' are flags,
``\texttt{-a -b}'' will work, but ``\texttt{-ab}'' will \textit{not}), and you
cannot merge a one-character option and its target
(``\texttt{-cfoo.dat}'' is \textit{not} a valid substitute for
``\texttt{-c foo.dat}'').

\bigskip

Some notable and useful command-line flags and options include:
\begin{itemize}
\item \texttt{--psf} \textit{psf-image} --- specifies a FITS image to be convolved
with the model image.

\bigskip

\item \texttt{--mask} \textit{mask-image} --- specifies a FITS image which marks
bad pixels to be ignored in the fitting process (by default, zero values in
the mask indicate \textit{good} pixels, and positive values indicate bad pixels).
\item \texttt{--mask-zero-is-bad} --- indicates that zero values (actually,
any value $< 1.0$) in the mask correspond to \textit{bad} pixels, with values
$\geq 1.0$ being good pixels.

\bigskip

\item \texttt{--noise} \textit{noisemap-image} --- specifies a pre-existing noise
or error FITS image to use in the fitting process (by default, pixel values in the
noise map are assumed to be sigma values).
\item \texttt{--errors-are-variances} --- indicates that pixel values in the noise
map are variances (sigma$^2$) instead of sigmas.
\item \texttt{--errors-are-weights} --- indicates that pixel values in the noise
map should be interpreted as weights, not as sigmas or variances.

\bigskip

\item \texttt{--sky} \textit{sky-level} --- specifies an original sky background
level (in counts/pixel) that was subtracted from the image; used for internal
computation of the noise map.
\item \texttt{--gain} \textit{value} --- specifies the A/D gain (electrons/ADU)
of the input image; used for internal computation of the noise map.
\item \texttt{--readnoise} \textit{value} --- specifies the read noise (electrons)
of the input image; used for internal computation of the noise map.
\item \texttt{--ncombined} \textit{value} --- if values in the input image are the
result of averaging (or computing the median of) two or more original images, then
this option should be used to specify the number of original images; used for internal 
computation of the noise map.  If multiple images were \textit{added} together
with no rescaling, then do not use this option.

\bigskip

\item \texttt{--save-params} \textit{output-filename} --- specifies that parameters 
for best-fitting model should be saved using the specified filename (default is
for these to be saved in a file named \texttt{bestfit\_parameters\_imfit.dat}).
\item \texttt{--save-model} \textit{output-filename} --- the best-fitting model image
will be saved using the specified filename.
\item \texttt{--save-residual} \textit{output-filename} --- the residual image (input
image $-$ best-fitting model image) will be saved using the specified filename.

\bigskip
\item \texttt{--de} --- use Differential Evolution instead of Levenberg-Marquardt as
the $\chi^2$ minimization technique (WARNING: much slower!)
\item \texttt{--chisquare-only} --- Evaluate the $\chi^2$ value for the initial input
model as a fit to the input image, \textit{without} doing any minimization to find
a better solution.

\bigskip

\item \texttt{--list-functions} --- list all the functions \imfit{} can use.

\item \texttt{--list-parameters} --- list all the individual parameters (in correct order)
for each of the functions that \imfit{} can use.
\end{itemize}




\section{The Configuration File}\label{sec:configfile}

\texttt{Imfit} always requires a configuration file, which specifies the model
which will be fit to the input image, initial values for model parameters, any
limits on parameter values (optional for fitting with the Levenberg-Marquardt
solver, but required for fitting with the Differential Evolution solver), and
possibly additional information (e.g, gain and read noise for the input image).

The configuration file should be a plain text file. Blank lines and
lines beginning with ``\#'' are ignored; in fact, anything after a
``\#'' is ignored, which allows for comments at the end of lines.

A model for an image is specified by one or more ``function blocks'', each of
which is a group of one or more 2D image functions sharing a common $(x,y)$
spatial position. Each function-specification consists of a line beginning with
``FUNCTION'' and containing the function name, followed by one or more lines
with specifications for that function's parameters.

\bigskip

More formally, the format for a configuration file is:
\begin{enumerate}
\item Optional specifications of general parameters and settings (e.g., the
input image's A/D gain and read noise)
\item One or more function blocks, each of which contains:
\begin{enumerate}
\item X-position parameter-specification line
\item Y-position parameter-specification line
\item One or more function + parameters specifications, each of which contains:
\begin{enumerate}
\item \texttt{FUNCTION} + function-name line
\item one or more parameter-specification lines
\end{enumerate}
\end{enumerate}
\end{enumerate}

This probably sounds more complicated than it is in practice.
Here is a very basic, bare-bones example of a configuration file:

\begin{quote}
  \texttt{X0  ~  150.1}\\
  \texttt{Y0  ~  149.5}\\
  \texttt{FUNCTION   Exponential}\\
  \texttt{PA  ~  95.0}\\
  \texttt{ell  ~  0.45}\\
  \texttt{I\_0 ~  90.0}\\
  \texttt{h   ~  15.0}\\
\end{quote}

This describes a model consisting of a single elliptical exponential
function, with initial values for the $x$ and $y$ position on the image,
the position angle (PA), the ellipticity (ell), the central intensity
(I\_0) in counts/pixel, and the exponential scale length in pixels (h).
None of the parameters have limits on their values.

Here is the same file, with some additional annotations and with limits on
some of the parameters (comments are colored red for clarity):

\begin{quote}
  \texttt{\red{\# This line is a comment}}\\
  
  \texttt{X0 ~~   150.1 ~  148,152}\\
  \texttt{Y0 ~~   149.5 ~  148,152         \red{\# a note}}\\
  \texttt{FUNCTION   Exponential  ~ \red{\# here is a comment}}\\
  \texttt{PA  ~  95.0  ~ 0,180   ~~   \red{\# limits on the position angle}}\\
  \texttt{ell  ~  0.45 ~ 0,1     ~~~ \red{\# ellipticity should always be 0--1}}\\
  \texttt{I\_0 ~  90.0 ~  fixed ~~~ \red{\# keep central intensity fixed}}\\
  \texttt{h    ~ 15.0}\\
\end{quote}

Here we can see the use of comments (lines or parts of lines beginning with
``\#'') and the use of parameter limits in the form of ``lower,upper'': the X0
and Y0 parameters are required to remain $\geq 148$ and $\leq 152$, the position
angle is limited to 0--180, the ellipticity must stay $\geq 0$ and $\leq 1$, and
the central intensity I\_0 is held fixed at its initial value.

Finally, here is a more elaborate example, specifying a model that has two
function blocks, with the first block having two individual functions (so this
could be a model for, e.g., simultaneously fitting two galaxies in the same
image, one as S\'ersic + exponential, the other with just an exponential):

\begin{quote}
  \texttt{\red{\# This line is a comment}}\\
  
  \texttt{GAIN  2.7   \red{\# A/D gain for image in e/ADU}}\\
  \texttt{READNOISE  4.5   \red{\# image read-noise in electrons}}\\
  
  \texttt{\red{\# This is the first function block: Sersic + exponential}}\\
  \texttt{X0 ~~   150.1  ~~ 148,152}\\
  \texttt{Y0 ~~   149.5  ~~ 148,152}\\
  \texttt{FUNCTION   Sersic   \red{\# A Sersic function}}\\
  \texttt{PA  ~  95.0  ~~ 0,180}\\
  \texttt{ell ~   0.05 ~ 0,1}\\
  \texttt{n   ~~   2.5  ~~~ 0.5,4.0 ~~ \red{\# Sersic index}}\\
  \texttt{I\_e ~  20.0 ~~ \red{\# intensity at the half-light radius}}\\
  \texttt{r\_e ~    5.0 ~~ \red{\# half-light radius in pixels}}\\
  \texttt{FUNCTION   Exponential}\\
  \texttt{PA   ~ 95.0  ~~ 0,180}\\
  \texttt{ell  ~  0.45  ~~0,1}\\
  \texttt{I\_0 ~  90.0  ~ fixed}\\
  \texttt{h    ~~ 15.0}\\
  
  \texttt{\red{\# This is the second function block: just a single exponential}}\\
  \texttt{X0 ~~   225.0  ~~ 224,226}\\
  \texttt{Y0 ~~   181.7  ~~ 180,183}\\
  \texttt{FUNCTION   Exponential} \\
  \texttt{PA   ~ 22.0  ~~ 0,180      }\\
  \texttt{ell  ~  0.25 ~ 0,1}\\
  \texttt{I\_0 ~  10.0  }\\
  \texttt{h   ~~~  20.0}\\
\end{quote}


\subsection{Parameter Names, Specifications, and Values}

The X0/Y0 position lines at the start of each function block and the
individual parameter lines for each function all share a common format:
\begin{quote}
\textit{parameter-name} ~~ \textit{initial-parameter-value} ~~ \textit{optional-limits}
\end{quote}
The separation between the individual pieces must consist of one or more spaces
and/or tabs. The final piece specifying the limits is optional (except that
fitting in Differential Evolution mode \textit{requires} that there be limits
for each parameter).

\bigskip

\textbf{Parameter Names:} The X0/Y0 positional parameters for each
function block must be labeled ``X0'' and ``Y0''. Names for the
parameters of individual functions can be anything the user desires;
only the order matters. Thus, the position-angle parameter could be
labeled ``PA'', ``PosAngle'', ``angle'', or any non-space-containing
string --- though it's a good idea to have it be something relevant
and understandable.

\textbf{Important Note:} \textit{Do not change the order of the parameters
for a particular function!}  Because the strings giving the parameter names
can be anything at all, \imfit{} actually ignores them and simply assumes
that all parameters are in the correct order for each function.

Note that any output which \imfit{} generates will use the default parameter
names defined in the individual function code (use ``\texttt{--list-parameters}''
to see what these are for each function).

\bigskip

\textbf{Values for Positional Parameter (X0, Y0)}: The positional parameters
for each function block are pixel values -- X0 for the column number and
Y0 for the row number. \Imfit{} uses the IRAF pixel-numbering
convention: the center of first pixel in the image (the lower left pixel
in a standard display) is at $(1.0,1.0)$, with the lower-left corner of that
pixel having the coordinates $(0.5,0.5)$.

\bigskip

\textbf{General Parameter Values for Functions}: The meaning of the individual
parameter values for the various 2D image functions is set by the functions
themselves, but in general: 
\begin{itemize}
\item position angles are measured in degrees counter-clockwise
from the image's vertical ($+y$) axis (i.e., degrees E of N if the image has standard
astronomical orientation);
\item ellipticity $= 1 - b/a$, where $a$ and $b$ are the
semi-major and semi-minor axes of an ellipse;
\item intensities are in counts/pixel;
\item lengths are in pixels. 
\end{itemize}
If you write your own functions, you are encouraged
to stick to these conventions.

\subsection{Parameter Limits}\label{sec:param-limits}

Individual parameters can be limited in two ways:
\begin{enumerate}
\item Held fixed;
\item Restricted to lie between lower and upper limits.
\end{enumerate}
To hold a parameter fixed, use the string ``fixed'' after the initial-value
specification, e.g.:
\begin{quote}
\texttt{X0} ~~ 442.85 ~~ fixed
\end{quote}
To specify lower and upper limits for a parameter, include them as a comma-separated
pair following the initial-value specification, e.g.:
\begin{quote}
\texttt{X0} ~~ 442.85 ~~ 441.0,443.5
\end{quote}



\section{Standard Image Functions}

\Imfit{} comes with the following 2D image functions, each of
which can be used as many times as desired. (As mentioned above, \imfit{}
is designed so that constructing and using new functions is a relatively
simple process.) Note that elliptical functions can always be made circular
by setting the ``ellipticity'' parameter to 0.0 and specifying that it be
held fixed. See Appendix~\ref{app:functions} for more complete discussions of each
function, including their parameters.

\begin{itemize}
\item FlatSky --- a uniform sky background.
\item Gaussian --- an elliptical 2D Gaussian function.
\item Moffat --- an elliptical 2D Moffat function.
\item Exponential --- an elliptical 2D exponential function.
\item Exponential\_GenEllipse --- an elliptical 2D exponential function using
generalized ellipses (``boxy'' to ``disky'' shapes) for the isophote shapes.
\item Sersic --- an elliptical 2D S\'ersic function.
\item Sersic\_GenEllipse --- an elliptical 2D S\'ersic function using
generalized ellipses (``boxy'' to ``disky'' shapes) for the isophotes.
\item FlatExponential --- similar to Exponential, but with an inner radial zone
of constant surface brightness for $r < R_{\rm break}$.
\item BrokenExponential --- similar to Exponential, but with \textit{two}
exponential radial zones (with different scalelengths) joined by a transition region
at $R_{\rm break}$ of variable sharpness.
\item GaussianRing --- an elliptical ring with a radial profile
consisting of a Gaussian centered at $r = R_{\rm ring}$.
\item GaussianRing2Side --- like GaussianRing, but with a radial profile
consisting of an asymmetric Gaussian (different values of $\sigma$ for
$r < R_{\rm ring}$ and $r > R_{\rm ring}$).
\item EdgeOnDisk --- the analytical form for a perfectly edge-on exponential
disk, using the Bessel-function solution of \citet{vdk81} for 
the radial profile and the generalized sech function of \citet{vdk88} 
for the vertical profile. Note that this function requires that the GNU
Scientific Library (GSL) be installed; if the GSL is not installed, \imfit{}
should be compiled without this function (see Section~\ref{sec:build}).
\item EdgeOnRing --- a simplistic model for an edge-on ring, using a
Gaussian for the radial profile and another Gaussian (with
different $\sigma$) for the vertical profile.
\item EdgeOnRing2Side --- like EdgeOnRing, but using an
asymmetric Gaussian for the radial profile (see description of GaussianRing2Side).

%Exponential, Exponential_GenEllipse, Sersic, Sersic_GenEllipse, Gaussian, 
%FlatExponential, BrokenExponential, BrokenExponential2D, EdgeOnDisk, Moffat, 
%FlatSky, EdgeOnDiskN4762, EdgeOnDiskN4762v2, EdgeOnRing, GaussianRing2Side.

\end{itemize}


A list of the currently available functions can always be obtained
by running \imfit{} with the ``\texttt{--list-functions}'' option:
\begin{quote}
  \texttt{\$ \imfit{} --list-functions}
\end{quote}
The complete list of function parameters for each function (suitable for copying
and pasting into a configuration file) can always be
obtained by running \imfit{} with the ``\texttt{--list-parameters}'' option:
\begin{quote}
  \texttt{\$ \imfit{} --list-paremeters}
\end{quote}




\section{Extras for Fitting Images}

\subsection{Specifying Image Subsections}

In many cases, you may want to fit an object which is much smaller than the whole
image. You can always make a smaller cutout image and fit that, but it may be convenient to
specify the image subsection directly. You can do this using a subset of the image-section
syntax of CFITSIO (which will be familiar to you if you've ever worked with
image sections in IRAF). An example:

\begin{quote}
ic3478rss\_256.fits[45:150,200:310]
\end{quote}
This will fit columns 45--150 and rows 200--310 of the image (column and row
numbering starts at 1). Pixel coordinates in the configuration (and output)
files refer to locations within the \textit{full} image.

The only kind of image section specification that's allowed is a simple
[x1:x2,y1:y2] format, though you can specify all of a particular dimension using
an asterisk (e.g., [*,y1:y2] to specify the full range of x values). More
complicated expressions which might extract part of a 3D datacube are not
(currently) possible. However, you \textit{can} specify a particular extension
(header-data unit) in a multi-extension FITS file, e.g.:

\begin{quote}
ic3478rss.fits[2]

ic3478rss.fits[2][45:150,200:310]
\end{quote}


Obviously, if you are also using a mask image (and/or a noise image), you should
specify the same subsection in those images!



\subsection{Masks}

A mask image can be supplied to \imfit{} by using the command-line
options \texttt{--mask}. The mask image should be an \textit{integer}-valued
FITS file with the same dimensions as the image being fitted (IRAF \texttt{.pl}
mask files are not recognized, but these can be converted to FITS format within
IRAF). The default is to treat zero-valued pixels in the mask image as
\textit{good} and pixels with values $> 0$ as \textit{bad} (i.e., to be excluded
from the fit); however, you can specify that zero-valued pixels are \textit{bad}
with the command-line flag \texttt{--mask-zero-is-bad}.



\subsection{Noise, Variance, or Weight Maps}

By default, \imfit{} calculates a weight map internally, using the input pixel
intensities, the A/D gain, the read noise, and any previously subtracted
background level to estimate Poisson errors $\sigma_{i}$ for each pixel $i$. The
final weight map is then $w_{i} = 1/\sigma^{2}_{i}$. These weights are then used in the 
$\chi^2$ calculation, summing over all $N$ pixels:
\begin{equation}
\chi^2 \; = \; \sum_{i = 0}^{N} w_{i} \, (I_{{\rm mod}, i} - I_{{\rm im}, i})^2 ,
\end{equation}
where $I_{{\rm mod}, i}$ and $I_{{\rm im}, i}$ are the model and data intensities
in counts/pixel, respectively. (Masking is handled by setting $w_{i} = 0$
for all masked pixels.)

If you have a pre-existing error map as a FITS image, you can tell \imfit{} to
use that instead, via the \texttt{--noise} command-line option. By default, the
pixel values in the FITS image are assumed to be errors $\sigma_{i}$ in
ADU/pixel. If the values are \textit{variances} ($\sigma_{i}^2$), you can specify
this with the \texttt{--errors-are-variances} flag. You can also tell \imfit{}
that the pixel values in the noise map are actual \textit{weights} $w_{i}$ via the
\texttt{--errors-are-weights} flag, if that happens to be the case. (If a mask
image is supplied, the weights of all masked pixels will still be set to 0,
regardless of their individual values in the weight image.)

Note that \imfit{} does \textit{not} try to obtain information (such as
the A/D gain or read noise) from the FITS header of an image. This is primarily
because there is little consistency in header names across the wide range of
astronomical images, so it is difficult pick one name, or even a small set, and
assume that it will be present in a given image's header; this is even more
true if an image is the result of a simulation. (And some image headers
use ``gain'' to mean \textit{inverse} gain (electrons/ADU) \ldots.)


\subsection{PSF Convolution}

TBD.

PSF images should be square, ideally with width = an odd number of pixels, and
the PSF should be centered in the central pixel. (An off-center PSF can certainly
be used, but the resulting convolved model images will be shifted.)



\section{Minimization Options: Levenberg-Marquardt vs.\ Differential Evolution}

The default $\chi^2$ minimization  used by \imfit{} is a Levenberg-Marquardt
algorithm, based on the classic MINPACK-1 implementation with enhancements by
Craig Markwardt.\footnote{Original C version available at
\url{http://www.physics.wisc.edu/~craigm/idl/cmpfit.html}} This is very fast and
robust, but requires an initial guess for the parameter values and can sometimes
become trapped in local minima in the $\chi^2$ landscape.

A semi-experimental alternate minimization algorithm is available via the
\texttt{--de} flag. This performs the $\chi^2$ minimization using Differential
Evolution (DE) \citep{de}, a genetic-algorithms approach which is, at least in
principle, more likely to find the global $\chi^2$
minimum.\footnote{\url{http://www.icsi.berkeley.edu/~storn/code.html}} It has
the drawback of being \textit{much} slower than Levenberg-Marquardt
minimization. For example, fitting a single S\'ersic function to the $256
\times 256$ image in the \texttt{examples/} subdirectory takes $\sim 60$ times
as long when using Differential Evolution as it does when using L-M minimization
(though this might be improved by specifying narrower parameter ranges in the
configuration file).

The Differential Evolution approach \textit{requires} lower and upper limits for
\textit{all} parameters in the configuration file (see
Section~\ref{sec:param-limits}); this is because DE generates 
parameter-value ``genomes'' by random uniform sampling from the ranges specified
by the parameter limits. The format of the configuration file still requires
that initial-guess values be present for all parameters as well, though these
are actually ignored by the DE algorithm. (This is to ensure that the same
configuration file can be used with either minimization routine.)

\medskip

TBD. [more details of DE implementation]

\medskip

Note that the DE algorithm does \textit{not} produce error estimates for the
best-fitting parameter values, in contrast to the Levenberg-Marquardt approach.
However, the L-M error estimates are themselves only reliable if the minimum in
the $\chi^{2}$ landscape is symmetric and parabolic, and if the errors for the
input image are truly Gaussian and well-determined.

\medskip

The fact that the minimization algorithms are relatively decoupled from the rest
of the code means that future versions of \imfit{} could potentially include
other minimization techniques.



\section{Output}

TBD.

Assuming that the fitting process converges, \imfit{} will print a summary of
the results, including the final, best-fitting parameter values. The output
parameter list is in the same format as the configuration file, except that
error estimates are listed after each parameter value.\footnote{If Differential
Evolution is used as the minimization technique, no errors are estimated.} The
error estimates are separated from the parameter values by ``\#''; this means
that you can copy and paste the parameter list into a text file and use that
file as an input configuration file for \imfit{} or \makeimage. 

The best-fitting parameters will also be written to an output text file (default
name = \texttt{bestfit\_parameters\_imfit.dat}; use \texttt{--save-params} to
specify a different name), \textit{without} the error estimates. The output file
will also include a copy of the original command used to start \imfit{} and the
date and time it was generated; these are commented out so that the file can be
used as an \imfit{} or \makeimage{} configuration file.

Also printed are the total $\chi^{2}$, the reduced $\chi^{2}$ (which accounts for the
total number of unmasked pixels and non-fixed parameter values), and two alternate
measures of the fit: the Akaike Information Criterion (AIC) and the Bayesian Information
Criterion (BIC). The latter two are included on a provisional basis; they are,
in principle, useful for comparing different models fit to the same data.

TBD.



\section{Makeimage}

\Imfit{} has a companion program called \makeimage, which will generate model
images using the same functions (and parameter files) as \imfit. In fact (as
noted above), the output ``best-fitting parameters'' file generated by \imfit{}
can be used as input to \makeimage, as can an \imfit{} configuration file.

\Makeimage{} \textit{does} require an output image size.  This can be specified
via command-line flags (``\texttt{--ncols}'' and ``\texttt{--nrows}''), via
specifications in the configuration file (see below), or by supplying a
reference FITS image (``\texttt{--refimage} \textit{image-filename}''); in the
latter case, the output image will have the same dimensions as the reference
image.

\Makeimage{} can also be run in a special mode to estimate the
magnitudes and fractional luminosities of different components in a
model.


\subsection{Using \Makeimage{}}

Basic use of \makeimage{} from the command line looks like this:
\begin{quote}
  \texttt{\$ \makeimage{} }  [options] ~ \textit{config-file}
\end{quote}
where \textit{config-file} is the name of the \imfit{}-style configuration file
which describes the model.

As for \imfit, the ``options'' are a set of command-line flags and
options (use ``\makeimage{} \texttt{-h}'' or ``\makeimage{} \texttt{--help}'' to
see the complete list). Options must be followed by an appropriate value
(e.g., a filename, an integer, a floating-point number); this can be
separated from the option by a space, or they can be connected with an
equals sign.

\bigskip

Some notable and useful command-line flags and options include:
\begin{itemize}
\item \texttt{--output} \textit{filename} --- filename for the output model
image (default = ``modelimage.fits'').

\item \texttt{--refimage} \textit{filename} --- existing reference image to
use for determining output image dimensions.

\item \texttt{--ncols} \textit{N\_columns} --- number of columns in output image

\item \texttt{--nrows} \textit{N\_rows} --- number of rows in output image

\bigskip

\item \texttt{--psf} \textit{psf-image} --- specifies a FITS image to be convolved
with the model image.

\bigskip

\item \texttt{--list-functions} --- list all the functions \makeimage{}
can use

\item \texttt{--list-parameters} --- list all the individual parameters (in correct order)
for each functions that \makeimage{} can use


\end{itemize}



\subsection{Configuration Files for \Makeimage{}}

The configuration file for \makeimage{} has essentially the same format as
that for \imfit; any parameter limits that might be present are ignored.

Optional general parameters like GAIN and READNOISE are ignored, but the
following optional general parameters are available:

\begin{itemize}
\item NCOLS --- number of columns for the output image (x-size)

\item NROWS --- number of rows for the output image (y-size)

\end{itemize}




\subsection{Generating Single-Function Output Images}

\Makeimage{} can also output individual images for each function
in the configuration file. For example, if the configuration file specifies
a model with one S\'ersic function and two exponential functions, \makeimage{}
can generate three separate FITS files, in addition to the (standard) sum of
all three functions.  This is done with the \texttt{--output-functions} option:
\begin{quote}
  \texttt{--output-functions} ~ \textit{root-name}
\end{quote}
where \textit{root-name} is a string that all output single-function filenames will
start with. The single-function filenames will be sequentially numbered (starting
with 1) according to the order of functions in the configuration file, and the
name of each function will added to the end; the resulting filenames will have
this format:
\begin{quote}
  \textit{root-name}{N}\texttt{\_}\textit{function-name}\texttt{.fits}
\end{quote}

Using the example specified above (a model with one S\'ersic and two exponential
functions), one could execute the following command
\begin{quote}
  \texttt{\$ \makeimage} ~ \textit{config-file} ~ \texttt{--output-functions mod}
\end{quote}
and the result would be three FITS files, named \texttt{mod1\_Sersic.fits},
\texttt{mod2\_Exponential.fits}, and \texttt{mod3\_Exponential.fits}.


\subsection{Using \Makeimage{} to Estimate Fluxes and Magnitudes}

Given a configuration file, you can use \makeimage{} to estimate the total
fluxes and magnitudes of different model components. For some components --
e.g., the purely elliptical versions of the Gaussian, Exponential, and Sersic
functions -- there are analytical expressions which could be used. But since
\imfit{} and \makeimage{} are designed to use arbitrary functions, including
ones which do not have analytical expressions for total flux, \makeimage{}
estimates the flux for each component by internally constructing a large model
image for each component function in the configuration file, centering the
component within the image and summing the pixel values of that image. The
output includes a list of total and relative fluxes for each component in the
model image (and their magnitudes, if a zero point is supplied).


\begin{quote}
  \texttt{\$ \makeimage{} }  --print-fluxes ~ \textit{config-file}
\end{quote}

Useful command-line flags and options:
\begin{itemize}

\item \texttt{--estimation-size} \textit{N\_columns\_and\_rows} --- size of the
(square) image to construct (the default size is 5000 pixels on a side)

\item \texttt{--zero-point} \textit{value} --- zero point for converting total counts
to magnitudes:
\begin{equation}
m \; = \; Z - 2.5 \log_{10}( {\rm counts} )
\end{equation}

\end{itemize}

This enables you to compute things like bulge/total ratios -- but it's up to you
which component(s) should be considered ``bulge'', ``disk'', etc.

When run in this mode, \makeimage{} will still produce an output image file --
unless you also specify the \texttt{--nosave} option.




\section{Rolling Your Own Functions}

\subsection{A Simple Example}

To illustrate how one might make a new function, we'll make a new version of
the Moffat function (which already exists, so this is purely for pedagogical purposes)
by copying and modifying the code for the Gaussian function.

\bigskip

We need to make three sets of changes:
\begin{itemize}
\item Change the class name from ``Gaussian'' to our new name (``NewMoffat'');
\item Change the relevant code which computes the function;
\item Rename, add, or delete variables to accomodate the new algorithm.
\end{itemize}


\subsubsection{Create and Edit the Header File}

Change directory to the directory with the \imfit{} source code, and then
\texttt{cd} to the ``\texttt{function\_objects}'' subdirectory. Copy the file
\texttt{func\_gaussian.h} and rename it to \texttt{func\_new-moffat.h}. Edit
this file and change the following lines:

\begin{verbatim}
#define CLASS_SHORT_NAME  "Gaussian"
\end{verbatim} 
(replace \texttt{"Gaussian"} with \texttt{"NewMoffat"})

\begin{verbatim}
class Gaussian : public FunctionObject
\end{verbatim}
(replace \texttt{Gaussian} with \texttt{NewMoffat})

\begin{verbatim}
    Gaussian( );
\end{verbatim}
(replace \texttt{Gaussian} with \texttt{NewMoffat})

And finally edit the list of class data members, changing this:
\begin{verbatim}
  private:
    double  x0, y0, PA, ell, I_0, sigma;   // parameters
    double  q, PA_rad, cosPA, sinPA;   // other useful (shape-related) quantities
\end{verbatim}
to this:
\begin{verbatim}
  private:
    double  x0, y0, PA, ell, I_0, fwhm, beta;   // parameters
    double  alpha;
    double  q, PA_rad, cosPA, sinPA;   // other useful (shape-related) quantities
\end{verbatim}


\subsubsection{Create and Edit the Class File}

Copy the file \texttt{func\_gaussian.cpp} and rename it to \texttt{func\_new-moffat.cpp}. 

\bigskip
\noindent \textit{Initial changes, including parameter number and names:}
\smallskip

Edit this file and change the following lines (changed text indicated in red):

\begin{quote}
\texttt{\#include "\red{func\_new-moffat.h}"} \\

const int  N\_PARAMS = \red{5}; \\

const char  PARAM\_LABELS[][20] = \{"PA", "ell", "I\_0", \red{"fwhm", "beta"}\}; \\

const char  FUNCTION\_NAME[] = "\red{Moffat} function";

\end{quote}

\bigskip
\noindent \textit{Change references to class name:}
\smallskip

Change all class references from ``Gaussian'' to ``NewMoffat'' (e.g., \texttt{Gaussian::Setup}
becomes \texttt{NewMoffat::Setup}).

\bigskip
\noindent \textit{Changes to Setup method:}
\smallskip

In the Setup method, you need to change how the input is converted into
parameters, and do any useful pre-computations. So the initial processing of
the ``params'' input changes from this:
\begin{verbatim}
  PA = params[0 + offsetIndex];
  ell = params[1 + offsetIndex];
  I_0 = params[2 + offsetIndex];
  sigma = params[3 + offsetIndex];
\end{verbatim}

to this:
\begin{verbatim}
  PA = params[0 + offsetIndex];
  ell = params[1 + offsetIndex];
  I_0 = params[2 + offsetIndex];
  fwhm = params[3 + offsetIndex];
  beta = params[4 + offsetIndex];
\end{verbatim}
and at the end we replace this:
\begin{verbatim}
  twosigma_squared = 2.0 * sigma*sigma;
\end{verbatim}
with this:
\begin{verbatim}
  // compute alpha:
  double  exponent = pow(2.0, 1.0/beta);
  alpha = 0.5*fwhm/sqrt(exponent - 1.0);
\end{verbatim}


\bigskip
\noindent \textit{Changes to CalculateIntensity method:}
\smallskip

This is the key place where your new function's algorithm is
implemented: the computation of the intensity as a function of (scaled)
radius.  Replace the original version of this method with the following:
\begin{verbatim}
double NewMoffat::CalculateIntensity( double r )
{
  double  scaledR, denominator;
  
  scaledR = r / alpha;
  denominator = pow((1.0 + scaledR*scaledR), beta);
  return (I_0 / denominator);
}
\end{verbatim}

\bigskip

In this simple example, we aren't changing the isophote geometry (i.e.,
we're still assuming a perfectly elliptical shape), so we don't need to
change the GetValue method, which converts pixel position to a scaled
radius value.  It probably doesn't make sense to change the
CalculateSubsamples method, either, so we can leave that alone.

At this point, most of the work is done.  We only need to update
\texttt{add\_functions.cpp} so it knows about the new function and
update the SConstruct file so that the new function is included in the
compilation, as described in the next section.


\subsubsection{Edit add\_functions.cpp}

We need to do three simple things here:
\begin{enumerate}
\item Include the header file for our new function. Add the following line near
the top of the file, where the other header files are included:\\
\texttt{\#include "func\_new-moffat.h"}

\item Modify the list of function names: Look for the lines beginning with
\begin{verbatim}
const char  FUNCTION_NAMES[][30] =
\end{verbatim}
and add \texttt{"NewMoffat"} to the list (add the name to both lists if the
function does not depend on the GNU Scientific Library; if it \textit{does} depend on GSL,
then add it to the first list only)

\item Add code to generate an instance of our new class as part of the
function-factory map. Inside the function PopulateFactoryMap, add the following lines:
\begin{verbatim}
  NewMoffat::GetClassShortName(classFuncName);
  input_factory_map[classFuncName] = new funcobj_factory<NewMoffat>();
\end{verbatim}

\end{enumerate}



\subsubsection{Edit the SConstruct File}

In the SConstruct file, locate the place where the variable
``functionobject\_obj\_string'' is defined (currently somewhere near line 269,
though this might change in the future). This is a string containing a
compact list of all the filenames containing function-object code. Insert our
new function's name (``func\_new-moffat'') into the list.

\bigskip

That's it! You should now be able to recompile \imfit{} and \makeimage{} 
(see Section~\ref{sec:build}) to use
the new function. (Assuming there aren't any bugs in your new code\ldots.)




\appendix
\section{Standard Functions in Detail}\label{app:functions}

Unless otherwise noted, all ``intensity'' parameters (\texttt{I\_sky},
\texttt{I\_0}, \texttt{I\_e}, etc.) are in units of counts per pixel, and all
lengths are in pixels.

A sample function specification (giving the parameters in their proper order) is
listed for each function description.

``Elliptical'' functions are defined to have an intensity which is constant on
concentric, similar ellipses (with specified ellipticity and major-axis position angle);
the intensity profile is defined as a function of the major axis $a$.

\medskip

\textbf{Common parameters}: 
\begin{itemize}
\item \texttt{PA} = position angle (e.g., of the major axis), measured in degrees CCW from
the image +y axis. This is equivalent to standard astronomical position angles \textit{if}
your image has standard astronomical orientation (N up, E to the left).
\item \texttt{ell} = ellipticity ($1 - b/a$, where $a$ and $b$ are semi-major and semi-minor
axes of the ellipse, respectively).
\end{itemize}


\subsection{FlatSky}

A uniform background: $I(x,y) = I_{\rm sky}$ everywhere.

\begin{verbatim}
FUNCTION FlatSky
I_sky
\end{verbatim}


\subsection{Gaussian}

This is an elliptical 2D Gaussian function, with the major-axis intensity
profile given by
\begin{equation}
I(a) \, = \, I_{0} \exp(-a^2/\sigma^2).
\end{equation}

\begin{verbatim}
FUNCTION Gaussian
PA
ell
I_0
sigma
\end{verbatim}


\subsection{Moffat}

This is an elliptical 2D Moffat function, with the major-axis intensity profile
given by
\begin{equation}
I(a) \, = \, \frac{I_{0}  }{(1 + (a/\alpha)^{2})^{\beta} },
\end{equation}
where $\alpha$ is defined as
\begin{equation}
\alpha \, = \, \frac{ {\rm FWHM}}{2 \sqrt{2^{1/\beta} - 1}}.
\end{equation}
In practice, FWHM describes the overall width of the profile, while $\beta$ describes that
strength of the wings: lower values of $\beta$ mean more intensity in the wings
than is the case for a Gaussian (as $\beta \rightarrow \infty$, the Moffat profile
approaches a Gaussian).

The Moffat function is often a good approximation to typical telescope PSFs (see, e.g.,
\citealt{trujillo01}), and \makeimage{} can easily be used to generate Moffat PSF images.

\begin{verbatim}
FUNCTION Moffat
PA
ell
I_0
fwhm
beta
\end{verbatim}


%  double  exponent = pow(2.0, 1.0/beta);
%  alpha = 0.5*fwhm/sqrt(exponent - 1.0);
%  q = 1.0 - ell;
%
%  scaledR = r / alpha;
%  denominator = pow((1.0 + scaledR*scaledR), beta);
%  return (I_0 / denominator);


\subsection{Exponential}

This is an elliptical 2D exponential function, with the major-axis intensity
profile given by
\begin{equation}
I(a) \, = \, I_{0} \exp(-a/h),
\end{equation}
where $I_{0}$ is the central surface brightness and $h$ is the scale length.

\begin{verbatim}
FUNCTION Exponential
PA
ell
I_0
h
\end{verbatim}


\subsection{Exponential\_GenEllipse}

Similar to the Exponential function, but using generalized ellipses (``boxy'' to
``disky'' shapes) instead of pure ellipses for the isophote shapes.  Following
\citet{athanassoula90}, the shape of the elliptical isophotes is controlled by
the \texttt{c0} parameter, such that a generalized ellipse with ellipticity $= 1
- b/a$ is described by
\begin{equation}
%\left( \frac{|x|}{a}^{c_{0} + 2} \right) + \left( \frac{|y|}{b}^{c_{0} + 2} \right) \; = \; 1,
\left( \frac{|x|}{a} \right)^{c_{0} + 2} + \left( \frac{|y|}{b} \right)^{c_{0} + 2} \; = \; 1,
\end{equation}
where $|x|$ and $|y|$ are distances from the ellipse center in the coordinate system
aligned with the ellipse major axis ($c_{0}$ corresponds to $c - 2$ in the original
formulation of Athanassoula et al).
Thus, values of $c_{0} < 0$ correspond to disky isophotes, while values $> 0$ describe boxy
isophotes; $c_{0} = 0$ corresponds to a perfect ellipse.

\begin{verbatim}
FUNCTION Exponential_GenEllipse
PA
ell
c0
I_0
h
\end{verbatim}


\subsection{S\'ersic}

This is an elliptical 2D S\'ersic function with the major-axis intensity
profile given by
\begin{equation}
I(a) \; = \; I_{e} \: \exp \left\{ -b_{n} \left[ \left( \frac{a}{r_{e}} \right)^{1/n} \! - \: 1 \right] \right\},
\end{equation}
where $I_{e}$ is the surface brightness at the effective (half-light) radius $r_{e}$
and $n$ is the S\'ersic index controlling the shape of the intensity profile. The
value of $b_{n}$ is formally given by the solution to the transcendental equation
\begin{equation}
\Gamma(2 n) \; = \; 2 \gamma(2n, b_{n}),
\end{equation}
where $\Gamma(a)$ is the gamma function and $\gamma(a, x)$ is the incomplete gamma function.
However, in the current implementation $b_{n}$ is calculated via the polynomial approximation
of \citet{ciotti99} when $n > 0.36$ and the approximation of \citet{macarthur03} when
$n \leq 0.36$.

Note that the S\'ersic function is equivalent to the de Vaucouleurs ``$r^{1/4}$'' profile
when $n = 4$, to an exponential when $n = 1$, and to a Gaussian when $n = 0.5$.

\begin{verbatim}
FUNCTION Sersic
PA
ell
n
I_e
r_e
\end{verbatim}


\subsection{Sersic\_GenEllipse}

Similar to the Sersic function, but using generalized ellipses (``boxy'' to
``disky'' shapes) instead of pure ellipses for the isophote shapes.  See the
discussion of the \texttt{Exponential\_GenEllipse} function above for details of the isophote
shapes.

\begin{verbatim}
FUNCTION Sersic_GenEllipse
PA
ell
c0
n
I_e
r_e
\end{verbatim}


\subsection{FlatExponential} 

Similar to Exponential, but with an inner radial zone ($a < r_{\rm break}$)
of constant surface brightness $I_{0}$.

\begin{verbatim}
FUNCTION FlatExponential
PA
ell
I_0
h
r_break
alpha
\end{verbatim}


\subsection{BrokenExponential}

Similar to Exponential, but with \textit{two}
exponential radial zones (with different scalelengths) joined by a transition region
at $R_{b}$ of variable sharpness:
\begin{equation}
	I(a) \; = \; S \, I_{0} \, e^{-\frac{a}{h_{1}}} [1 + e^{\alpha(a \, - \,
	R_{b})}]^{\frac{1}{\alpha} (\frac{1}{h_{1}} \, - \, \frac{1}{h_{2}})},
\end{equation}
where $I_{0}$ is the central intensity of the inner exponential, $h_{1}$ and
$h_{2}$ are the inner and outer exponential scale lengths, $R_{b}$ is the break radius, and
$\alpha$ parameterizes the sharpness of the break.  (See \citet{erwin08}.) Low values of $\alpha$
mean very smooth, gradual breaks, while high values correspond to abrupt
transitions.  $S$ is a scaling factor, given by
\begin{equation}
  S \; = \; (1 + e^{-\alpha R_{b}})^{\frac{1}{\alpha} (\frac{1}{h_{1}} \, - 
  \, \frac{1}{h_{2}})}.
\end{equation}

Note that the parameter $\alpha$ has units of length$^{-1}$ (i.e., pixels$^{-1}$).

\begin{verbatim}
FUNCTION BrokenExponential
PA
ell
I_0
h1
h2
r_break
alpha
\end{verbatim}


\subsection{GaussianRing}

An elliptical ring with a radial profile consisting of a Gaussian
centered at $r = R_{\rm ring}$.

\begin{verbatim}
FUNCTION GaussianRing
PA
ell
A
R_ring
sigma_r
\end{verbatim}


\subsection{GaussianRing2Side}

Similar to GaussianRing, but now using an asymmetric Gaussian (different
values of $\sigma$ for $r < R_{\rm ring}$ and $r > R_{\rm ring}$).

\begin{verbatim}
FUNCTION GaussianRing2Side
PA
ell
A
R_ring
sigma_r_in
sigma_r_out
\end{verbatim}


\subsection{EdgeOnDisk}

This function provides the analytical form for a perfectly edge-on disk with a radial exponential
profile, using the Bessel-function solution of \citet{vdk81} for 
the radial profile and the generalized sech function of \citet{vdk88} 
for the vertical profile. The position angle parameter (PA) describes the angle of
the disk plane; there is no ellipticity parameter.

% *      Sigma(r,z) = I_0 * (r/h) * K_1(r/h) * sech^alpha(r/(alpha*z0))
% *
% *    with Sigma(0,0) = 2 * h * I_0
% *
% *   This should corresponds to a face-on disk with:
% *      Sigma(r) = Sigma(0,0) * exp(-r/h)
% *   although this is guaranteed to be true only for alpha = 2 [i.e., that is
% * the most direct match to van der Kruit & Searle 1981]
% *
% *   Note that for the case of a sech^2 vertical profile (alpha = 2), our z0
% * is 1/2 of the usual z0 in e.g. van der Kruit & Searle (1981).

In a coordinate system aligned with the edge-on disk, the intensity at radius $r$ from 
the central axis (in the direction parallel to the galaxy plane) and
at height $z$ from the midplane is given by
\begin{equation}
I(r,z) \; = \; \mu(0,0) \; (r/h) \; K_{1}(r/h) \; {\rm sech}^{\alpha} (r/(\alpha z_{0}))
\end{equation}
where $h$ is the exponential scale length in the disk plane, $z_{0}$ is the vertical
scale height, and $K_{1}$ is the modified Bessel function. The central surface brightness 
$\mu(0,0)$ is given by
\begin{equation}
\mu(0,0) \; = \;  2 \, h \, L_{0},
\end{equation}
where $L_{0}$ is the central luminosity \textit{density} (see \citealt{vdk81}). Note that 
$L_{0}$ is the actual parameter required by the function ($\mu(0,0)$ is calculated 
internally).

When $\alpha = 2$, this reduces to the familiar $\mathrm{sech}^2$ model for the
vertical distribution of a disk (with $z_{0}$ corresponding to $1/2$ of the
$z_0$ in the original definition of \citet{vdk81}). When $\alpha = \infty$, the
vertical distribution becomes exponential; in practice, you can approximate this
by setting $\alpha$ equal to some fixed, large number.

Note that this particular function requires that the GNU Scientific Library
(GSL) be installed; if the GSL is not installed, \imfit{} should be compiled
without this function. (The pre-compiled binary versions include the necessary
code from the GSL.)

\begin{verbatim}
FUNCTION EdgeOnDisk
PA
L_0
h
alpha
z_0
\end{verbatim}


\subsection{EdgeOnRing}

A simplistic model for an edge-on ring, using two offset components located
at distance $\pm$\texttt{r} from the center of the function block. Each component
(i.e., each side of the ring) is a symmetric Gaussian with size
\texttt{sigma\_r} for the radial profile and a symmetric Gaussian with
size \texttt{sigma\_z} for the vertical profile.

\begin{verbatim}
FUNCTION EdgeOnRing
PA
I_0
r
sigma_r
sigma_z
\end{verbatim}


\subsection{EdgeOnRing2Side}

Similar to EdgeOnRing, but now the radial profile for the two components is
asymmetric: the inner ($|R| < R_{\rm ring}$) side of each component is a Gaussian
with radial size \texttt{sigma\_r\_in}, while the outer side has radial size
\texttt{sigma\_r\_out}.

\begin{verbatim}
FUNCTION EdgeOnRing2Side
PA
I_0
r
sigma_r_in
sigma_r_out
sigma_z
\end{verbatim}



\section{Acknowledgments}

Major inspirations for \Imfit{} include both GALFIT \citep{peng02,peng10} and 
BUDDA \citep{desouza04,gadotti08}.

Thanks also to Michael Opitsch and Michael Williams for being (partly unwitting) beta
testers, and for their feedback.

\subsection{Data Sources}

Sample FITS images for demonstration and testing use are taken from Data Release
7 \citep{abazajian09} of the Sloan Digital Sky Survey \citep{york00}. Funding
for the creation and distribution of the SDSS Archive has been provided by the
Alfred P. Sloan Foundation, the Participating Institutions, the National
Aeronautics and Space Administration, the National Science Foundation, the U.S.
Department of Energy, the Japanese Monbukagakusho, and the Max Planck Society. 
The SDSS Web site is \url{http://www.sdss.org/}.

The SDSS is managed by the Astrophysical Research Consortium (ARC) for
the Participating Institutions.  The Participating Institutions are
The University of Chicago, Fermilab, the Institute for Advanced Study,
the Japan Participation Group, The Johns Hopkins University, the
Korean Scientist Group, Los Alamos National Laboratory, the
Max-Planck-Institute for Astronomy (MPIA), the Max-Planck-Institute
for Astrophysics (MPA), New Mexico State University, University of
Pittsburgh, University of Portsmouth, Princeton University, the United
States Naval Observatory, and the University of Washington.



\subsection{Specific Software Acknowledgments}

\subsubsection{Minpack}
This product includes software developed by the University of Chicago, as Operator of
the Argonne National Laboratory.



\bibliographystyle{plainnat}

\begin{thebibliography}{}


\bibitem[Abazajian et al.(2009)]{abazajian09} Abazajian, K. N.., et al.\ 2009, ``The Seventh 
Data Release of the Sloan Digital Sky Survey'', \textit{Astrophys.J. Supplement} \textbf{182}: 182

\bibitem[Athanassoula et al.(1990)]{athanassoula90} Athanassoula, E., Morin, S., Wozniak, H.,
Puy, D., Pierce, M. J., Lombard, J., \& Bosma, A. 1990, \textit{Monthly Notices of the Royal
Astronomical Society} \textbf{245}: 130.

\bibitem[Ciotti \& Bertin(1999)]{ciotti99} Ciotti, L., \& Bertin, G. 1999,
''Analytical properties of the R$^{1/m}$ law'', \textit{Astron.\ Astrophys.}
\textbf{352}: 447.

\bibitem[de Souza, Gadotti, \& dos Anjos(2004)]{desouza04} de Souza, R. E.,
Gadotti, D. A., \& dos Anjos, S. 2004, ``BUDDA: A New Two-dimensional Bulge/Disk
Decomposition Code for Detailed Structural Analysis of Galaxies'',
\textit{Astrophys.J. Supplement} \textbf{153}: 411.

\bibitem[Erwin, Pohlen, \& Beckman(2008)]{erwin08} Erwin, P.,
Pohlen, B., \& Beckman, J. E. 2008, ``The Outer Disks of Early-Type Galaxies. I. 
Surface-Brightness Profiles of Barred Galaxies'', \textit{Astron.J.} \textbf{135}: 20.

\bibitem[Gadotti(2008)]{gadotti08} Gadotti, D. A. 2008, ``Image decomposition of barred galaxies and AGN hosts'',
\textit{Monthly Notices of the Royal
Astronomical Society} \textbf{384}: 420.

\bibitem[Krist(1995)]{krist95} Krist, J. 1995, ``Simulation of HST PSFs using Tiny Tim'', 
in \textit{Astronomical Data Analysis Software and Systems IV}, 
R.A. Shaw, H.E. Payne, and J.J.E. Hayes, eds., \textit{ASP Conference Series} \textbf{77}: 349.

\bibitem[MacArthur, Courteau, \& Holtzman(2003)]{macarthur03} MacArthur, L. A.,
Courteau, S., \& Holtzman, J. A. 2003, ``Structure of Disk-dominated Galaxies.
I. Bulge/Disk Parameters, Simulations, and Secular Evolution'',
\textit{Astrophys.J.} \textbf{582}: 689.

\bibitem[Peng et al.(2002)]{peng02} Peng, C. Y., Ho, L. C., Impey, C. D., \&
Rix, H. W. 2002, ``Detailed Structural Decomposition of Galaxy Images'',
\textit{Astron.J.} \textbf{124}: 266

\bibitem[Peng et al.(2010)]{peng10} Peng, C. Y., Ho, L. C., Impey, C. D., \&
Rix, H. W. 2010, ``Detailed Structural Decomposition of Galaxy Images'',
\textit{Astron.J.} \textbf{139}: 2097

\bibitem[S{\'e}rsic(1968)]{sersic68} S{\'e}rsic, J.-L. 1968, \textit{Atlas de 
Galaxias Australes} (Cordoba: Obs.\ Astron.)

\bibitem[Storn \& Price(1997)]{de} Storn, R. and Price, K. 1997, ``Differential Evolution --
A Simple and Efficient Heuristic for Global Optimization Over Continuous Spaces'', 
\textit{Journal of Global Optimization} \textbf{11}: 314

\bibitem[Trujillo et al.(2001)]{trujillo01} Trujillo, I., Aguerri, J. A. L.,
Cepa, J., \& Guti{\'e}rrez, C. M. 2001, ``The effects of seeing on S{\'e}rsic
profiles -- II. The Moffat PSF'', \textit{Monthly Notices of the Royal
Astronomical Society} \textbf{328}: 977.

\bibitem[van der Kruit \& Searle(1981)]{vdk81} van der Kruit, P. C., \&
Searle, L. 1981, ``Surface Photometry of Edge-on Spiral Galaxies: I. A
Model for the Three-dimensional Distribution of Light in Galactic
Disks'', \textit{Astron.\ Astrophys.} \textbf{95}: 105

\bibitem[van der Kruit(1988)]{vdk88} van der Kruit, P. 1988, ``The
Three-dimensional Distribution of Light and Mass in Disks of Spiral
Galaxies'', \textit{Astron.\ Astrophys.} \textbf{192}: 117

\bibitem[York et al.(2000)]{york00} York, D. G., et al.\ 2000, ``The Sloan Digital 
Sky Survey: Technical Summary'', \textit{Astron.J.} \textbf{120}: 1579


\end{thebibliography}
%\bibliography{imfit_howto}




\end{document}
